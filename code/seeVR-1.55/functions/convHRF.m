% Copyright (C) Alex A. Bhogal, 2021, University Medical Center Utrecht,
% a.bhogal@umcutrecht.nl
% <convHRF: convolved an input signal with a double-gamma hemodynamic response function (HRF) >
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <https://www.gnu.org/licenses/>.
%
% ************************************************************************
% This function takes uses the supplied options (opts.onset, opts.disp,
% opts.under) to generate a series of hemodynamic response functions
% (HRFs). These HRFs are then convolved with the input probe.
%
% probe: input probe to be regressed with HRF
%
% opts: options structure containing required variables for this specific
% function; i.e. opts.plot, opts.rratio, opts.onset, opts.disp, opts.under
%
% HRF: an array of double-gamma functions produced by the corresponding
% input functions
%
% HRFidx: index associated with each HRF. This is used in the fitHRF
% function
%
% HRF_probe: an array consisting of normalized time-series' generated by
% convolving the input probe with the HRF functions. The first vector entry
% is the normalized (0-1) probe.
function [HRF, HRFidx, HRF_probe] = convHRF(probe, opts)


warning('off')
global opts;
%set defaults
if isfield(opts,'verbose'); else; opts.verbose = 0; end %turn plotting on or off
if isfield(opts,'rratio'); else; opts.rratio = 1000; end %seems to affect the vertical spread of HRF (use large value to limit)
if isfield(opts,'onset'); else; opts.onset = 1; end %parameter that defines response onset
if isfield(opts,'disp'); else; opts.disp = [1:.5:30]; end %dispersion parameter - set a default vector
if isfield(opts,'under'); else; opts.under = 1; end %parameter that defines undershoot
if isfield(opts,'pad'); else; opts.pad = 1; end %pad before fft
if isfield(opts,'padfront'); else; opts.padfront = 1; end %pad before fft

input_probe = rescale(probe);

if opts.pad
    pad = 2^nextpow2(length(probe));
else
    pad = 0;
end
if opts.padfront && opts.pad
    probe = zeros(length(input_probe)+pad,1);
    probe(1:pad) = input_probe(1,1);
    probe(pad+1:end,1) = input_probe;
else
    probe = zeros(length(input_probe)+2*pad,1);
    probe(1:pad) =  input_probe(1,1);
    probe(pad+1:end-pad,1) = input_probe;
    probe(end-pad+1:end,1) =  input_probe(1,end);
end
mm=0;
xdata = (1:1:length(probe));
clear HRF
HRFidx(1,:,:,:) = [1 1 1];

for ii = opts.onset %onset
    for jj =  opts.disp %dispersion
        for kk = opts.under %undershoot
            mm = mm+1;
            V = [ii jj kk];
            t = (0:1:length(xdata)-1);
            h_final = zeros(length(t),1);
            alpha_1 = V(1);
            beta_1 = V(2);
            alpha_2 = alpha_1;
            beta_2 = V(3);
            
            h = ((t.^(alpha_1 - 1)).*(((beta_1).^(-alpha_1)).*(exp((1./(-beta_1)).*t))))./(gamma(alpha_1));
            h2 = ((t.^(alpha_2 - 1)).*(((beta_2).^(-alpha_2)).*(exp((1./(-beta_2)).*t))))./(opts.rratio.*gamma(alpha_2));
            
            h_final = h - h2;
            h_final = h_final./trapz(h_final);
            
            HRF(mm,:) = h_final;
            HRFidx(mm+1,:,:,:) = V;
        end
    end
end

% convolve HRF with probe
HRF_probe = zeros([mm+1 length(probe)]);
HRF_probe(1,:) = probe/trapz(probe);
newprobe_freq = fftshift(fft(probe)/trapz(probe));

for ii=1:size(HRF,1)
    HRF_freq(ii,:) = fftshift(fft(HRF(ii,:)/trapz(HRF(ii,:))));
    tmp = real(ifft(ifftshift(HRF_freq(ii,end:-1:1).*newprobe_freq')));
    HRF_probe(ii+1,:) = (tmp/trapz(tmp)); %normalize HRF
    HRF_probe(ii+1,:) =   HRF_probe(ii+1,end:-1:1);
end

if opts.padfront && opts.pad
    HRF_probe(:,1:pad) = [];
else
    HRF_probe(:,1:pad) = []; HRF_probe(:,end-pad+1:end) = [];  %remove padding
end
for ii=1:size(HRF_probe,1); HRF_probe(ii,:) = rescale(HRF_probe(ii,:)); end
if opts.verbose
    figure;
 
    if size(HRF,1) == 1
    customMap = colormap(viridis(128));
    else
    customMap = colormap(flip(brewermap(size(HRF,1),'Spectral')));
    end
    
    for ii=1:size(HRF,1)
        subplot(1,2,1); plot(t,HRF(ii,:)', 'Color', customMap(ii,:)); ylim([-0.2 1]); xlim([0 30]); title('double gamma HRF'); hold on;
        subplot(1,2,2); plot(HRF_probe(ii+1,:)', 'Color', customMap(ii,:)); xlim([0 size(HRF_probe,2)]); hold on;
    end
    plot( HRF_probe(1,:), 'k', 'LineWidth', 2);  title('HRF probe');
    set(gcf, 'Units', 'pixels', 'Position', [200, 500, 600, 160]);
    if isfield(opts,'figdir')
        saveas(gcf,[opts.figdir,'HRF_fnc.fig']);
    else
        if ispc
            saveas(gcf,[pwd,'\','HRF_fnc.fig']);
        else
            saveas(gcf,[pwd,'/','HRF_fnc.fig']);
        end
    end
end